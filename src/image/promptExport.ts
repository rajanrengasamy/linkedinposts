/**
 * Prompt Export Module
 *
 * Exports image generation prompts and branding assets for manual
 * Gemini image generation instead of calling the API.
 *
 * This module generates a complete set of assets that allow users to
 * manually generate infographics using Google Gemini's web interface,
 * avoiding API costs while maintaining brand consistency.
 *
 * Output structure:
 * - branding-book.md: Human-readable brand guide
 * - branding-book.json: Machine-readable brand data
 * - prompts/infographic-N.txt: Ready-to-use prompts
 * - metadata.json: Generation metadata and instructions
 * - README.md: Quick-start guide
 *
 * @see docs/manual-image-generation-approach.md for full documentation
 */

import { mkdir, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import type { InfographicBrief, LinkedInPost } from '../schemas/synthesisResult.js';
import type { PipelineConfig } from '../types/index.js';
import { RESOLUTION_TO_IMAGE_SIZE, IMAGE_MODEL } from '../types/image.js';
import { buildInfographicPrompt, ACCENT_PALETTE } from './nanoBanana.js';
import {
  generateBrandingBookData,
  renderBrandingBookMarkdown,
  inferAccentColor,
  BRANDING_BOOK_SCHEMA_VERSION,
} from './brandingBook.js';
import type { PromptExportMetadata, PromptExportResult } from './types.js';
import { logVerbose } from '../utils/logger.js';

// ============================================
// Constants
// ============================================

/**
 * Directory name for image assets within output folder
 */
const IMAGE_ASSETS_DIR = 'image-assets';

/**
 * Directory name for prompts within image-assets folder
 */
const PROMPTS_DIR = 'prompts';

/**
 * Schema version for metadata files
 */
const METADATA_SCHEMA_VERSION = '1.0.0';

/**
 * Resolution to recommended pixel dimensions
 */
const RESOLUTION_TO_PIXELS: Record<string, string> = {
  '2k': '1080x1080',
  '4k': '2160x2160',
};

// ============================================
// README Generation
// ============================================

/**
 * Generate the README.md content for the image-assets directory
 */
function generateReadme(
  promptCount: number,
  recommendedColor: string,
  recommendedHex: string
): string {
  const promptList =
    promptCount === 1
      ? '- `prompts/infographic-1.txt`'
      : Array.from({ length: promptCount }, (_, i) => `- \`prompts/infographic-${i + 1}.txt\``)
          .join('\n');

  return `# Image Generation Assets

## Quick Start

1. **Open Gemini**: Visit https://gemini.google.com/
2. **Copy Prompt**: Open a prompt file from \`prompts/\` and copy the entire contents
3. **Paste & Generate**: Paste into Gemini and click generate
4. **Download**: Save the generated image

## Files in This Directory

| File | Purpose |
|------|---------|
| \`branding-book.md\` | Human-readable brand guidelines |
| \`branding-book.json\` | Machine-readable brand data |
| \`prompts/\` | Ready-to-use prompts for each post |
| \`metadata.json\` | Generation context and instructions |
| \`README.md\` | This file |

## Available Prompts

${promptList}

## Brand Overview

- **Background**: Dark charcoal (#1e1e1e)
- **Recommended Accent**: ${capitalize(recommendedColor)} (${recommendedHex})
- **Icon Style**: Line-art only, 2-3px stroke
- **Typography**: Geometric sans-serif, white text

## Multi-Post Mode

${
  promptCount > 1
    ? `You have ${promptCount} posts. Generate each infographic separately in Gemini using the corresponding prompt file.`
    : 'Single post mode - use `prompts/infographic-1.txt`.'
}

## Tips for Best Results

1. **Copy the entire prompt** - don't skip any sections
2. **Regenerate if needed** - Gemini may need a few attempts
3. **Check brand consistency** - ensure dark background and correct accent color
4. **Download as PNG** - highest quality for LinkedIn

---

*Generated by LinkedIn Post Generator - Stage 6 Prompt Export System*
`;
}

/**
 * Capitalize the first letter of a string
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// ============================================
// Metadata Generation
// ============================================

/**
 * Generate metadata.json content
 */
function generateMetadata(
  topic: string,
  prompts: PromptExportMetadata[],
  config: PipelineConfig
): object {
  return {
    schemaVersion: METADATA_SCHEMA_VERSION,
    generatedAt: new Date().toISOString(),

    pipeline: {
      version: '1.0.0',
      synthesisModel: config.synthesisModel,
      imageMode: 'export',
    },

    topic,
    postCount: prompts.length,
    postStyle: config.postStyle,

    prompts,

    resolution: {
      configured: config.imageResolution,
      apiFormat: RESOLUTION_TO_IMAGE_SIZE[config.imageResolution],
      recommendedPixels: RESOLUTION_TO_PIXELS[config.imageResolution] || '1080x1080',
    },

    geminiInstructions: {
      webUrl: 'https://gemini.google.com/',
      model: IMAGE_MODEL,
      howToUse: [
        '1. Open Gemini web interface at https://gemini.google.com/',
        '2. Copy the entire contents of the prompt file',
        '3. Paste into the prompt field',
        '4. Click generate and wait for the image',
        '5. If the result is not satisfactory, regenerate',
        '6. Download the generated image as PNG',
      ],
    },
  };
}

// ============================================
// Single Post Export
// ============================================

/**
 * Export prompts and branding assets for manual image generation.
 *
 * Creates a complete set of files in the `image-assets/` subdirectory
 * of the output folder, containing everything needed to manually
 * generate infographics using Gemini.
 *
 * @param brief - Single infographic brief from synthesis
 * @param topic - The original topic/prompt
 * @param config - Pipeline configuration
 * @param outputDir - Base output directory (e.g., output/2025-12-30_14-43-11)
 * @returns Export result with file paths
 */
export async function exportPromptAssets(
  brief: InfographicBrief,
  topic: string,
  config: PipelineConfig,
  outputDir: string
): Promise<PromptExportResult> {
  // Create directory structure
  const assetsDir = join(outputDir, IMAGE_ASSETS_DIR);
  const promptsDir = join(assetsDir, PROMPTS_DIR);
  await mkdir(promptsDir, { recursive: true });

  // Generate branding book
  const brandingData = generateBrandingBookData(brief, topic);
  const brandingMarkdown = renderBrandingBookMarkdown(brandingData);

  // Generate the full image prompt
  const resolutionLabel = config.imageResolution; // '2k' or '4k'
  const promptText = buildInfographicPrompt(brief, resolutionLabel);

  // File paths
  const brandingBookMdPath = join(assetsDir, 'branding-book.md');
  const brandingBookJsonPath = join(assetsDir, 'branding-book.json');
  const metadataJsonPath = join(assetsDir, 'metadata.json');
  const readmeMdPath = join(assetsDir, 'README.md');
  const promptPath = join(promptsDir, 'infographic-1.txt');

  // Create prompt metadata
  const promptMeta: PromptExportMetadata = {
    postNumber: 1,
    file: 'prompts/infographic-1.txt',
    charCount: promptText.length,
    infographicBrief: {
      title: brief.title,
      keyPoints: brief.keyPoints,
      suggestedStyle: brief.suggestedStyle,
      accentColor: brief.accentColor,
    },
  };

  // Generate metadata
  const metadata = generateMetadata(topic, [promptMeta], config);

  // Generate README
  const readme = generateReadme(
    1,
    brandingData.recommendedAccent.color,
    brandingData.recommendedAccent.hex
  );

  // Write all files
  await Promise.all([
    writeFile(brandingBookMdPath, brandingMarkdown, 'utf-8'),
    writeFile(brandingBookJsonPath, JSON.stringify(brandingData, null, 2), 'utf-8'),
    writeFile(metadataJsonPath, JSON.stringify(metadata, null, 2), 'utf-8'),
    writeFile(readmeMdPath, readme, 'utf-8'),
    writeFile(promptPath, promptText, 'utf-8'),
  ]);

  logVerbose(`Exported image assets to ${assetsDir}`);
  logVerbose(`  - Branding book: ${brandingBookMdPath}`);
  logVerbose(`  - Prompt: ${promptPath} (${promptText.length} chars)`);

  return {
    outputDir: assetsDir,
    promptCount: 1,
    files: {
      brandingBookMd: brandingBookMdPath,
      brandingBookJson: brandingBookJsonPath,
      metadataJson: metadataJsonPath,
      readmeMd: readmeMdPath,
      prompts: [promptPath],
    },
  };
}

// ============================================
// Multi-Post Export
// ============================================

/**
 * Export prompts for multiple posts (multi-post mode).
 *
 * Creates separate prompt files for each post's infographic,
 * with a shared branding book and metadata file.
 *
 * @param posts - Array of LinkedIn posts with their infographic briefs
 * @param topic - The original topic/prompt
 * @param config - Pipeline configuration
 * @param outputDir - Base output directory
 * @returns Export result with file paths
 */
export async function exportMultiplePromptAssets(
  posts: LinkedInPost[],
  topic: string,
  config: PipelineConfig,
  outputDir: string
): Promise<PromptExportResult> {
  // Create directory structure
  const assetsDir = join(outputDir, IMAGE_ASSETS_DIR);
  const promptsDir = join(assetsDir, PROMPTS_DIR);
  await mkdir(promptsDir, { recursive: true });

  // Use the first post's brief for branding book (they share the same brand)
  const firstBrief = posts[0].infographicBrief;
  const brandingData = generateBrandingBookData(firstBrief, topic);
  const brandingMarkdown = renderBrandingBookMarkdown(brandingData);

  // Generate prompts for each post
  const resolutionLabel = config.imageResolution;
  const promptMetadata: PromptExportMetadata[] = [];
  const promptPaths: string[] = [];

  const writePromises: Promise<void>[] = [];

  for (const post of posts) {
    const promptText = buildInfographicPrompt(post.infographicBrief, resolutionLabel);
    const promptFileName = `infographic-${post.postNumber}.txt`;
    const promptPath = join(promptsDir, promptFileName);

    promptMetadata.push({
      postNumber: post.postNumber,
      file: `prompts/${promptFileName}`,
      charCount: promptText.length,
      infographicBrief: {
        title: post.infographicBrief.title,
        keyPoints: post.infographicBrief.keyPoints,
        suggestedStyle: post.infographicBrief.suggestedStyle,
        accentColor: post.infographicBrief.accentColor,
      },
    });

    promptPaths.push(promptPath);
    writePromises.push(writeFile(promptPath, promptText, 'utf-8'));
  }

  // File paths
  const brandingBookMdPath = join(assetsDir, 'branding-book.md');
  const brandingBookJsonPath = join(assetsDir, 'branding-book.json');
  const metadataJsonPath = join(assetsDir, 'metadata.json');
  const readmeMdPath = join(assetsDir, 'README.md');

  // Generate metadata and README
  const metadata = generateMetadata(topic, promptMetadata, config);
  const readme = generateReadme(
    posts.length,
    brandingData.recommendedAccent.color,
    brandingData.recommendedAccent.hex
  );

  // Write all files
  await Promise.all([
    writeFile(brandingBookMdPath, brandingMarkdown, 'utf-8'),
    writeFile(brandingBookJsonPath, JSON.stringify(brandingData, null, 2), 'utf-8'),
    writeFile(metadataJsonPath, JSON.stringify(metadata, null, 2), 'utf-8'),
    writeFile(readmeMdPath, readme, 'utf-8'),
    ...writePromises,
  ]);

  logVerbose(`Exported ${posts.length} image prompts to ${assetsDir}`);
  for (const meta of promptMetadata) {
    logVerbose(`  - Post ${meta.postNumber}: ${meta.file} (${meta.charCount} chars)`);
  }

  return {
    outputDir: assetsDir,
    promptCount: posts.length,
    files: {
      brandingBookMd: brandingBookMdPath,
      brandingBookJson: brandingBookJsonPath,
      metadataJson: metadataJsonPath,
      readmeMd: readmeMdPath,
      prompts: promptPaths,
    },
  };
}
